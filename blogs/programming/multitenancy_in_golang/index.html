<!doctype html><html lang=en><head><title>Multitenancy Using Golang :: Favas M</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Hello! In this article, I will explain how to build a multi-tenant system in Golang. Before we dive in, I&rsquo;d like to mention that this is my first blog post, so there may be some mistakes or areas lacking clarity. The content is based on my experience building a multi-tenant system in Golang at work. If there&rsquo;s a better way to approach this or potential drawbacks in the method described, I&rsquo;d appreciate your feedback.
"><meta name=keywords content="multi-tenancy,Golang,Go multi-tenant,multi-tenant architecture,schema isolation Golang,Golang tutorial,multi-tenancy tutorial,Golang multi-tenant system,schema-level isolation,Chi routing,PostgreSQL multi-tenant"><meta name=robots content="noodp"><link rel=canonical href=https://favas.dev/blogs/programming/multitenancy_in_golang/><link rel=stylesheet href=https://favas.dev/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css><link rel=stylesheet href=https://favas.dev/css/code.min.00125962708925857e7b66dbc58391d55be1191a3d0ce2034de8c9cd2c481c36.css><link rel=stylesheet href=https://favas.dev/css/fonts.min.90c955c31dd7c0e05aae3d4f583d4d8a2af799d69c961337eaf2a825063a55dd.css><link rel=stylesheet href=https://favas.dev/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css><link rel=stylesheet href=https://favas.dev/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://favas.dev/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css><link rel=stylesheet href=https://favas.dev/css/main.min.1d8be2dd1b5de9fdaed058c8c59fcf4485f36619574abfb47ed0cfda4812c16d.css><link rel=stylesheet href=https://favas.dev/css/menu.min.83637a90d903026bc280d3f82f96ceb06c5fc72b7c1a8d686afb5bbf818a29f7.css><link rel=stylesheet href=https://favas.dev/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css><link rel=stylesheet href=https://favas.dev/css/post.min.fc74ca360273c1d828da3c02b8174eba435607b369d98418ccc6f2243cd4e75d.css><link rel=stylesheet href=https://favas.dev/css/prism.min.9023bbc24533d09e97a51a0a42a5a7bfe4c591ae167c5551fb1d2191d11977c0.css><link rel=stylesheet href=https://favas.dev/css/syntax.min.cc789ed9377260d7949ea4c18781fc58959a89287210fe4edbff44ebfc1511b6.css><link rel=stylesheet href=https://favas.dev/css/terminal.min.736caf886baa67df630c4cde30fbdc5115122eb74c6246f15a31401344bfa2f0.css><link rel=stylesheet href=https://favas.dev/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://favas.dev/terminal.css><link rel="shortcut icon" href=https://favas.dev/favicon.png><link rel=apple-touch-icon href=https://favas.dev/apple-touch-icon.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="clevrf0x"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Multitenancy Using Golang"><meta property="og:description" content="Hello! In this article, I will explain how to build a multi-tenant system in Golang. Before we dive in, I&rsquo;d like to mention that this is my first blog post, so there may be some mistakes or areas lacking clarity. The content is based on my experience building a multi-tenant system in Golang at work. If there&rsquo;s a better way to approach this or potential drawbacks in the method described, I&rsquo;d appreciate your feedback.
"><meta property="og:url" content="https://favas.dev/blogs/programming/multitenancy_in_golang/"><meta property="og:site_name" content="Favas M"><meta property="og:image" content="https://favas.dev/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="Programming"><meta property="article:section" content="Golang"><meta property="article:section" content="SaaS"><meta property="article:section" content="Multi-tenancy"><meta property="article:published_time" content="2024-09-21 16:25:54 +0530 +0530"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>clevrf0x</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/blogs>Blogs</a></li><li><a href=/contact>Contact</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/blogs>Blogs</a></li><li><a href=/contact>Contact</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://favas.dev/blogs/programming/multitenancy_in_golang/>Multitenancy Using Golang</a></h1><div class=post-meta><time class=post-date>2024-09-21</time><span class=post-author>Favas M</span></div><span class=post-tags>#<a href=https://favas.dev/tags/golang/>golang</a>&nbsp;
#<a href=https://favas.dev/tags/saas/>saas</a>&nbsp;
#<a href=https://favas.dev/tags/multi-tenancy/>multi-tenancy</a>&nbsp;
#<a href=https://favas.dev/tags/coding/>coding</a>&nbsp;
#<a href=https://favas.dev/tags/tutorial/>tutorial</a>&nbsp;</span><div class=post-content><div><p>Hello! In this article, I will explain how to build a multi-tenant system in Golang. Before we dive in, I&rsquo;d like to mention that this is my first blog post, so there may be some mistakes or areas lacking clarity. The content is based on my experience building a multi-tenant system in Golang at work. If there&rsquo;s a better way to approach this or potential drawbacks in the method described, I&rsquo;d appreciate your feedback.</p><p>Keep in mind that I haven&rsquo;t tested this system in a high-traffic production environment, so it may have performance limitations. Please adapt the approach to your specific needs and use cases.</p><h3 id=tldr>TL;DR:<a href=#tldr class=hanchor arialabel=Anchor>#</a></h3><p>This post shares my experience building a multi-tenant system in Golang. The example code is meant to illustrate the concept and might have unhandled exceptions or security vulnerabilities. Make sure to thoroughly review and test the code before deploying it in a production environment.</p><h3 id=what-is-multi-tenancy>What is Multi-Tenancy<a href=#what-is-multi-tenancy class=hanchor arialabel=Anchor>#</a></h3><p>Before we explore how to build a multi-tenant system, let&rsquo;s clarify what multi-tenancy is. According to Wikipedia, &ldquo;Multitenancy is a software architecture where a single instance of an application serves multiple users or organizations&rdquo;, users are often referred to as &rsquo;tenants.'</p><p>But what does that mean? Imagine you have a product with two users who both need identical environments but require their data to be completely isolated. In the past, the solution was to host two separate instances of the application, either on-premises or in the cloud. However, this approach has several downsides:</p><ul><li>It becomes expensive to spin up new servers for every user.</li><li>Managing separate instances becomes difficult as the user base grows. For example, managing 100 instances for 100 customers can be a huge headache.</li><li>Different instances might run different versions of the app, leading to inconsistency.</li><li>Handling database migrations across multiple environments can become a major challenge.</li></ul><p><img alt="Single Tenant Application Architecture" src=/blogs/programming/multi-tenancy-in-golang/single-tenant-architecture.png></p><p>What&rsquo;s the alternative? Instead of spinning up separate instances, we could host a single instance of the application where every tenant can interact with it, while still keeping their data isolated. This is where multi-tenancy comes in.</p><p>Using a multi-tenant architecture allows us to:</p><ul><li>Roll out version updates and database migrations across all tenants simultaneously.</li><li>Reduce operational overhead by managing a single instance.</li><li>Lower infrastructure costs.</li></ul><h3 id=real-world-examples-of-multi-tenant-architecture>Real-world Examples of Multi-Tenant Architecture<a href=#real-world-examples-of-multi-tenant-architecture class=hanchor arialabel=Anchor>#</a></h3><p>Many popular SaaS products use multi-tenancy successfully. Here are a few examples:</p><ul><li>Microsoft Office 365</li><li>GitHub</li><li>Twilio</li><li>Canva</li><li>Atlassian Products (e.g., Jira, Confluence)</li></ul><p><img alt="Multi-Tenant Application Architecture" src=/blogs/programming/multi-tenancy-in-golang/multi-tenant-architecture.png></p><h3 id=how-to-achieve-data-isolation-in-multi-tenancy>How to Achieve Data Isolation in Multi-Tenancy<a href=#how-to-achieve-data-isolation-in-multi-tenancy class=hanchor arialabel=Anchor>#</a></h3><p>Now that we understand what multi-tenancy is, let&rsquo;s explore how to implement it in a way that ensures data isolation between tenants. There are primarily three methods for achieving this, each with its own pros and cons:</p><h4 id=1-database-level-isolation>1. Database-Level Isolation<a href=#1-database-level-isolation class=hanchor arialabel=Anchor>#</a></h4><p>In database-level isolation, each tenant&rsquo;s data is stored in a separate database. A shared public database is used for common data.</p><h5 id=pros>Pros:<a href=#pros class=hanchor arialabel=Anchor>#</a></h5><ul><li>Each tenant&rsquo;s data is completely isolated in a separate database.</li><li>Low risk of accidentally accessing cross-tenant data.</li></ul><h5 id=cons>Cons:<a href=#cons class=hanchor arialabel=Anchor>#</a></h5><ul><li>Tenants cannot have foreign key relationships between their data and the shared public database.</li><li>Switching between tenant databases and the public database adds performance overhead. This can be mitigated by injecting separate database sessions into your handlers.</li><li>It&rsquo;s complex to implement and maintain.</li></ul><h4 id=2-schema-level-isolation>2. Schema-Level Isolation<a href=#2-schema-level-isolation class=hanchor arialabel=Anchor>#</a></h4><p>In schema-level isolation, all tenants share the same database, but their data is separated into individual schemas. A shared public schema is used for common data.</p><h5 id=pros-1>Pros:<a href=#pros-1 class=hanchor arialabel=Anchor>#</a></h5><ul><li>Data is isolated at the schema level, similar to database-level isolation.</li><li>No significant performance overhead when switching between public and tenant schemas.</li><li>Reduced complexity compared to database-level isolation.</li><li>Reusing the same database connection for both tenant and public data is easier to implement.</li></ul><h5 id=cons-1>Cons:<a href=#cons-1 class=hanchor arialabel=Anchor>#</a></h5><ul><li>Less strict data isolation compared to database-level isolation.</li></ul><h4 id=3-row-level-isolation>3. Row-Level Isolation<a href=#3-row-level-isolation class=hanchor arialabel=Anchor>#</a></h4><p>In row-level isolation, each tenant&rsquo;s data is stored in the same tables, but a &ldquo;tenant ID&rdquo; column is added to differentiate records by tenant.</p><h5 id=pros-2>Pros:<a href=#pros-2 class=hanchor arialabel=Anchor>#</a></h5><ul><li>Simple to implement and maintain.</li><li>Easy to apply database migrations.</li><li>Foreign key relationships between tables can be maintained as needed.</li></ul><h5 id=cons-2>Cons:<a href=#cons-2 class=hanchor arialabel=Anchor>#</a></h5><ul><li>Data is less isolated compared to database or schema-level isolation.</li><li>There&rsquo;s a higher risk of accidental cross-tenant data access through query errors.</li></ul><h4 id=other-methods>Other Methods<a href=#other-methods class=hanchor arialabel=Anchor>#</a></h4><p>There are additional methods, such as creating prefixed tables for each tenant (e.g., <code>tenant1_users</code>, <code>tenant2_users</code>). However, this approach is less common because it complicates database migrations and increases maintenance efforts.</p><h3 id=how-to-implement-multi-tenancy>How to Implement Multi-Tenancy<a href=#how-to-implement-multi-tenancy class=hanchor arialabel=Anchor>#</a></h3><p>For this blog post, we will be implementing schema-level isolation. After weighing the pros and cons of each approach, I believe schema-level isolation provides a balanced trade-off between complexity and data isolation, making it a good choice for this demonstration.</p><p>To keep this project as a proof of concept, we&rsquo;ll use a minimal set of dependencies. Here&rsquo;s the stack we&rsquo;ll be working with:</p><ul><li><strong>Routing:</strong> We&rsquo;ll use the Chi library for routing. It&rsquo;s lightweight, easy to use, and simplifies middleware implementation, making the codebase more manageable.</li><li><strong>Database Interaction:</strong> For database queries, we&rsquo;ll use <code>sqlc</code> to generate Go code, ensuring type safety with minimal boilerplate.</li><li><strong>Migrations:</strong> Goose will handle our database migrations, allowing for smooth updates to the database schema as new tenants are added.</li><li><strong>Database:</strong> We&rsquo;ll use PostgreSQL, which natively supports schema-level isolation, making it the ideal choice for this project.</li></ul><p>With these tools, we&rsquo;ll go step-by-step through setting up multi-tenancy using schema-level isolation.</p><h3 id=project-structure>Project Structure<a href=#project-structure class=hanchor arialabel=Anchor>#</a></h3><p>Now this project structure will seem a bit redundant or strange for some of the Go developers. This is how I generally build projects in Golang. Since this is not a blog about how to build API servers in Golang, I will not dwell deep into the structure; I will explain as much as I can of each package and file&rsquo;s purposes as we progress.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>.
</span></span><span style=display:flex><span>├── api
</span></span><span style=display:flex><span>│   ├── middlewares
</span></span><span style=display:flex><span>│   │   └── auth.go
</span></span><span style=display:flex><span>│   ├── middleware.go
</span></span><span style=display:flex><span>│   └── router.go
</span></span><span style=display:flex><span>├── cmd
</span></span><span style=display:flex><span>│   ├── app
</span></span><span style=display:flex><span>│   │   └── main.go
</span></span><span style=display:flex><span>│   └── migrate
</span></span><span style=display:flex><span>│       └── main.go
</span></span><span style=display:flex><span>├── db
</span></span><span style=display:flex><span>│   ├── migrations
</span></span><span style=display:flex><span>│   │   ├── public
</span></span><span style=display:flex><span>│   │   │   └── 00001_init_public_schema.sql
</span></span><span style=display:flex><span>│   │   └── tenant
</span></span><span style=display:flex><span>│   │       └── 00001_init_tenant_schema.sql
</span></span><span style=display:flex><span>│   ├── queries
</span></span><span style=display:flex><span>│   │   ├── public
</span></span><span style=display:flex><span>│   │   │   ├── public_files.sql
</span></span><span style=display:flex><span>│   │   │   ├── tenants.sql
</span></span><span style=display:flex><span>│   │   │   └── user_lookup.sql
</span></span><span style=display:flex><span>│   │   └── tenant
</span></span><span style=display:flex><span>│   │       ├── tenant_files.sql
</span></span><span style=display:flex><span>│   │       └── users.sql
</span></span><span style=display:flex><span>│   ├── sqlc
</span></span><span style=display:flex><span>│   │   ├── db.go
</span></span><span style=display:flex><span>│   │   ├── models.go
</span></span><span style=display:flex><span>│   │   ├── public_files.sql.go
</span></span><span style=display:flex><span>│   │   ├── tenant_files.sql.go
</span></span><span style=display:flex><span>│   │   ├── tenants.sql.go
</span></span><span style=display:flex><span>│   │   ├── user_lookup.sql.go
</span></span><span style=display:flex><span>│   │   └── users.sql.go
</span></span><span style=display:flex><span>│   ├── db.go
</span></span><span style=display:flex><span>│   ├── migrations.go
</span></span><span style=display:flex><span>│   └── tenant.go
</span></span><span style=display:flex><span>├── handlers
</span></span><span style=display:flex><span>│   ├── auth_service
</span></span><span style=display:flex><span>│   │   ├── login.go
</span></span><span style=display:flex><span>│   │   └── register.go
</span></span><span style=display:flex><span>│   ├── tenant_service
</span></span><span style=display:flex><span>│   │   └── get_tenant.go
</span></span><span style=display:flex><span>│   └── healthcheck.go
</span></span><span style=display:flex><span>├── pkg
</span></span><span style=display:flex><span>│   └── helpers
</span></span><span style=display:flex><span>│       ├── json.go
</span></span><span style=display:flex><span>│       ├── jwt.go
</span></span><span style=display:flex><span>│       ├── password.go
</span></span><span style=display:flex><span>│       ├── response.go
</span></span><span style=display:flex><span>│       └── utils.go
</span></span><span style=display:flex><span>├── server
</span></span><span style=display:flex><span>│   └── server.go
</span></span><span style=display:flex><span>├── .air.toml
</span></span><span style=display:flex><span>├── docker-compose.yml
</span></span><span style=display:flex><span>├── .env.example
</span></span><span style=display:flex><span>├── .gitignore
</span></span><span style=display:flex><span>├── go.mod
</span></span><span style=display:flex><span>├── go.sum
</span></span><span style=display:flex><span>├── Makefile
</span></span><span style=display:flex><span>├── README.md
</span></span><span style=display:flex><span>└── sqlc.yml
</span></span></code></pre></div><p>Here’s a simple proof of concept I built using Go Chi, PostgreSQL, SQLC, and Goose.</p><p><strong>Disclaimer:</strong><br>This code is intended purely as a demonstration of multi-tenancy concepts and is not production-ready. To keep the implementation straightforward, many best practices and security measures have been intentionally omitted. For example:</p><ul><li>Errors are not properly handled.</li><li>User inputs are not validated.</li><li>Security measures are insufficiently implemented.</li></ul><p>Please use this codebase only as a reference or for learning purposes.<br><strong>Reference:</strong> <a href=https://github.com/clevrf0x/go-multitenancy>https://github.com/clevrf0x/go-multitenancy</a></p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><a href=https://favas.dev/blogs/hackthebox/challenges/reversing/simple-encryptor/ class="button inline prev">Simple Encryptor Walkthrough - HackTheBox
</a>::
<a href=https://favas.dev/blogs/programming/dart_cheatsheet/ class="button inline next">Dart Cheatsheet</a></div></div></article></div><script type=text/javascript src=/bundle.min.js></script></div></body></html>